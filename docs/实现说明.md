# 实现说明

## 整体架构

本实现采用了多线程架构，将指令发送、数据接收、数据处理和UI更新分离，确保各模块并行运行且不会阻塞UI线程。

### 主要组件

1. **CommandSender**（指令发送器）
   - 负责按顺序发送指令
   - 每个指令发送后等待响应，确保指令顺序执行
   - 响应结果放入响应队列

2. **DataProcessor**（数据处理器）
   - 从响应队列获取响应数据
   - 使用线程池并行处理数据
   - 处理结果放入结果队列

3. **TestManager**（测试管理器）
   - 协调各组件工作
   - 提供UI更新回调接口
   - 管理测试流程和结果

## 工作流程

1. **指令发送流程**
   ```
   UI → TestManager → CommandSender → 通信接口 → 硬件
   ```

2. **响应处理流程**
   ```
   硬件 → 通信接口 → CommandSender → 响应队列 → DataProcessor → 结果队列 → UI
   ```

3. **UI更新流程**
   - 指令状态更新（发送中、已发送、已接收、处理完成）
   - 接收数据实时显示
   - 处理结果实时显示

## 配置文件

测试指令和响应帧定义存储在`test_commands.yaml`文件中，格式如下：

```yaml
commands:
  - description: "激活测试模式"
    hex_data: "AA 55 55 AA 88 88 00 10 00 00 00 00 CF 10 00 01 00 00 0D EE"
  
response_frames:
  - description: "激活测试模式响应"
    hex_data: "AA 55 55 AA 88 88 00 10 00 00 00 00 CF 10 00 01 00 00 0D EE"
```

## 关键特性

1. **线程安全**：所有队列操作和状态更新均为线程安全
2. **顺序保证**：指令发送严格按顺序执行，确保上一个指令响应返回后再发送下一个
3. **并行处理**：数据处理使用线程池，可同时处理多个响应
4. **实时更新**：指令状态、接收数据和处理结果实时更新到UI
5. **可扩展性**：各组件独立，便于扩展和维护

## 使用示例

```python
# 初始化测试管理器
test_manager = TestManager()

# 定义回调函数
def on_status_update(status):
    print(f"状态更新：{status}")

def on_error(error):
    print(f"错误：{error}")

def on_test_complete(results):
    print(f"测试完成：{results}")

def on_command_updated(command, status):
    print(f"指令更新：{command['description']} - {status}")

def on_data_processed(result):
    print(f"数据处理完成：{result['command']['description']}")

# 开始测试
test_manager.start_test(
    on_status_update,
    on_error,
    on_test_complete,
    on_command_updated,
    on_data_processed
)
```
